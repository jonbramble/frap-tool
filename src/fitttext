Fitting::Fitting(gsl_matrix* m){
	int i = (int)m->size1;  //images
	int j = (int)m->size2;  //pixels in selection
	
	//std::cout << i << std::endl;
	//std::cout << j << std::endl;

	gsl_vector *fitdata = gsl_vector_alloc(j); //allocate vector

	gsl_matrix_get_row(fitdata,m,1); //put data in vector

	 
	const gsl_multifit_fdfsolver_type * T;
	gsl_multifit_fdfsolver *s;
       	int status;
       	unsigned int it, iter = 0;
       	const size_t n = j;	//number of variables
       	const size_t p = 3;	//number of points

	//gsl_matrix *covar = gsl_matrix_alloc (p, p);
	
	double y[n],sigma[n]; //set sigma to one for no weighting
	
	struct data d = {n,y,sigma};

	gsl_multifit_function_fdf f;

	double x_init[3] = { 1.0, 0.0, 0.0 }; // A lambda mu
       	gsl_vector_view x = gsl_vector_view_array (x_init, p); //whats this for
	
	f.f = &gauss_f;
       	f.df = &gauss_df;
       	f.fdf = &gauss_fdf;
       	f.n = n;
       	f.p = p;
       	f.params = &d;	

	T = gsl_multifit_fdfsolver_lmsder; //Levenberg-Marquardt
       	s = gsl_multifit_fdfsolver_alloc (T, n, p);

	gsl_vector_free(fitdata);
	gsl_multifit_fdfsolver_free (s);
       	//gsl_matrix_free (covar);
	
}

int Fitting::gauss_f(const gsl_vector * x, void *data, gsl_vector * f){

       size_t n = ((struct data *)data)->n;
       double *y = ((struct data *)data)->y;
       double *sigma = ((struct data *) data)->sigma;
     
       double A = gsl_vector_get (x, 0);
       double lambda = gsl_vector_get (x, 1);
       double mu = gsl_vector_get (x, 2);
     
       size_t i;
     
       for (i = 0; i < n; i++)
         {
	   //* Model Yi = A * exp((-(i-mu)^2)/lambda)
           double t = i;
           double Yi = A * exp (-1*pow((t - mu),2)/lambda);
	   
           gsl_vector_set (f, i, (Yi - y[i])/sigma[i]);
         }

     	return GSL_SUCCESS;
}

int Fitting::gauss_df(const gsl_vector * x, void * params, gsl_matrix * J)
{
 	size_t n = ((struct data *)data)->n;
       double *sigma = ((struct data *) data)->sigma;
     
       double A = gsl_vector_get (x, 0);
       double lambda = gsl_vector_get (x, 1);
     
       size_t i;
     
       for (i = 0; i < n; i++)
         {
           /* Jacobian matrix J(i,j) = dfi / dxj, */
           /* where fi = (Yi - yi)/sigma[i],      */
           /*       Yi = A * exp(-lambda * i) + b  */
           /* and the xj are the parameters (A,lambda,b) */
           double t = i;
           double s = sigma[i];
           double e = exp(-lambda * t);
           gsl_matrix_set (J, i, 0, e/s); 
           gsl_matrix_set (J, i, 1, -t * A * e/s);
           gsl_matrix_set (J, i, 2, 1/s);
         }


	return GSL_SUCCESS;
}

int Fitting::gauss_fdf(const gsl_vector * x, void * params, gsl_vector * f, gsl_matrix * J)
{
	int a = gauss_f(x, data, f);
       int b = gauss_df(x, data, J);
     
	return GSL_SUCCESS;
}
